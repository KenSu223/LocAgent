{"instance_id": "pallets__flask-2264", "repo": "pallets/flask", "base_commit": "cb94f4c5d3d4e1797207fd03d20d06c7bc0d05b4", "problem_statement": "Handle app factory in FLASK_APP\n\n`FLASK_APP=myproject.app:create_app('dev')`\r\n[\r\nGunicorn does this with `eval`](https://github.com/benoitc/gunicorn/blob/fbd151e9841e2c87a18512d71475bcff863a5171/gunicorn/util.py#L364), which I'm not super happy with. Instead, we could use `literal_eval` to allow a simple list of arguments. The line should never be so complicated that `eval` would be necessary anyway.\r\n\r\n~~~python\r\n# might need to fix this regex\r\nm = re.search(r'(\\w+)(\\(.*\\))', app_obj)\r\n\r\nif m:\r\n    app = getattr(mod, m.group(1))(*literal_eval(m.group(2)))\r\n~~~", "patch": "", "file_loc": {"base_commit": "cb94f4c5d3d4e1797207fd03d20d06c7bc0d05b4", "files": [{"path": "flask/cli.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [11, 12]}, "(None, 'find_best_app', 32)": {"mod": [58, 62, 69, 71]}, "(None, 'call_factory', 82)": {"mod": [82, 83, 84, 85, 86, 88, 89, 90, 91, 92, 93]}, "(None, 'locate_app', 125)": {"mod": [151, 153, 154, 155, 156, 158]}}}, {"path": "tests/test_cli.py", "status": "modified", "Loc": {"(None, 'test_locate_app', 148)": {"add": [152], "mod": [154, 155, 156, 157, 158, 159, 160, 161]}}}]}}
{"instance_id": "pallets__flask-593", "repo": "pallets/flask", "base_commit": "85dce2c836fe03aefc07b7f4e0aec575e170f1cd", "problem_statement": "Nestable blueprints\n\nI'd like to be able to register \"sub-blueprints\" using `Blueprint.register_blueprint(*args, **kwargs)`. This would register the nested blueprints with an app when the \"parent\" is registered with it. All parameters are preserved, other than `url_prefix`, which is handled similarly to in `add_url_rule`. A na\u00edve implementation could look like this:\n\n``` python\nclass Blueprint(object):\n    ...\n\n    def register_blueprint(self, blueprint, **options):\n        def deferred(state):\n            url_prefix = options.get('url_prefix')\n            if url_prefix is None:\n                url_prefix = blueprint.url_prefix\n            if 'url_prefix' in options:\n                del options['url_prefix']\n\n            state.app.register_blueprint(blueprint, url_prefix, **options)\n        self.record(deferred)\n```", "patch": "", "file_loc": {"base_commit": "85dce2c836fe03aefc07b7f4e0aec575e170f1cd", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, 71)": {"add": [71]}}}, {"path": "docs/blueprints.rst", "status": "modified", "Loc": {"(None, None, 122)": {"add": [122]}}}, {"path": "src/flask/app.py", "status": "modified", "Loc": {"('Flask', '__call__', 1982)": {"add": [1987]}, "('Flask', 'update_template_context', 712)": {"mod": [726, 727, 728]}, "('Flask', 'register_blueprint', 971)": {"mod": [990, 992, 993, 994, 995, 996, 997, 998, 999, 1000, 1001, 1002, 1004]}, "('Flask', '_find_error_handler', 1230)": {"mod": [1238, 1239, 1240, 1241, 1242, 1243, 1244]}, "('Flask', 'preprocess_request', 1741)": {"mod": [1752, 1755, 1756, 1761, 1762]}, "('Flask', 'process_response', 1768)": {"mod": [1782, 1784, 1785]}, "('Flask', 'do_teardown_request', 1794)": {"mod": [1818, 1819, 1820]}}}, {"path": "src/flask/blueprints.py", "status": "modified", "Loc": {"('BlueprintSetupState', '__init__', 16)": {"add": [47]}, "('Blueprint', '__init__', 141)": {"add": [170]}, "('Blueprint', 'register', 213)": {"add": [225], "mod": [281, 282, 286, 287, 288, 289, 290, 291, 292, 293]}, "('BlueprintSetupState', 'add_url_rule', 53)": {"mod": [71]}, "('Blueprint', None, 78)": {"mod": [213]}}}, {"path": "tests/test_blueprints.py", "status": "modified", "Loc": {"(None, 'test_app_url_processors', 828)": {"add": [852]}}}]}}
{"instance_id": "pallets__flask-602", "repo": "pallets/flask", "base_commit": "ee76129812419d473eb62434051e81d5855255b6", "problem_statement": "Misspelling in docs @ flask.Flask.handle_exception\n\n`Default exception handling that kicks in when an exception occours that is not caught. In debug mode the exception will be re-raised immediately, otherwise it is logged and the handler for a 500 internal server error is used. If no such handler exists, a default 500 internal server error message is displayed.`\n\nOccours should be occurs.\n\nI looked around in the project code to see if i could update this, but it looks like the docs subdir is no longer used? I could be wrong, if you let me know where this is at I'll update it and send a PR :)", "patch": "", "file_loc": {"base_commit": "ee76129812419d473eb62434051e81d5855255b6", "files": [{"path": "flask/app.py", "status": "modified", "Loc": {"('Flask', 'handle_exception', 1266)": {"mod": [1268]}}}]}}
{"instance_id": "pallets__flask-2813", "repo": "pallets/flask", "base_commit": "07c7d5730a2685ef2281cc635e289685e5c3d478", "problem_statement": "Allow flexible routing with SERVER_NAME config\n\n### Expected Behavior\r\n\r\nDeployed a flask application which is reachable over multiple domains and ports:\r\n- external via load balancer: `client - Host: example.org -> LB -> flask app`\r\n- internal via DNS service discovery without load balancer: `client - Host: instance-1231.example.org -> flask app` \r\n\r\nIf the client connects directly (`Host: instance-1231.example.org`) the app should be able to return absolute and stable URLs like `http://example.org/path/to/my/view` as the URL (`http://instance-1231.example.org/path/to/my/view`) with the internal DNS name is ephemeral.\r\nTherefore I configured the `SERVER_NAME` config key and `url_for` generates the intended absolute URL by using `_external=True` within and without request context. But the app should be still able to route requests coming with `Host: instance-1231.example.org`.\r\n\r\n### Actual Behavior\r\n\r\nFlasks creates the `werkzeug.routing.MapAdapter` with `server_name=app.config['SERVER_NAME']` and therefore no view method will match to incoming requests with `Host: instance-1231.example.org`.\r\n\r\n### Environment\r\n\r\n* Python version: 2.7.13 (I'm sorry)\r\n* Flask version: 1.0.2\r\n* Werkzeug version: 0.14.1\r\n\r\n### Applied workaround:\r\n\r\nOverwrite `Flask.create_url_adapter` and create `MapAdapter` for request context without `server_name` parameter. Routing and URL generation works fine.", "patch": "", "file_loc": {"base_commit": "07c7d5730a2685ef2281cc635e289685e5c3d478", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [25]}}}, {"path": "docs/config.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [270], "mod": [263, 264, 266, 267]}}}, {"path": "src/flask/app.py", "status": "modified", "Loc": {"('Flask', 'create_url_adapter', 423)": {"add": [436], "mod": [428, 430, 431, 432, 439, 440, 441, 442, 443, 444, 445, 448, 449, 450, 452, 453]}}}, {"path": "tests/test_basic.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [6, 1485]}}}, {"path": "tests/test_blueprints.py", "status": "modified", "Loc": {"(None, 'test_nesting_subdomains', 953)": {"add": [970], "mod": [954, 963, 965, 967, 968, 969]}, "(None, 'test_child_and_parent_subdomain', 974)": {"add": [994], "mod": [975, 976, 978, 985, 987, 989, 990, 991, 992, 993, 997]}}}]}}
{"instance_id": "pallets__flask-3555", "repo": "pallets/flask", "base_commit": "024f0d384cf5bb65c76ac59f8ddce464b2dc2ca1", "problem_statement": "Remove simplejson\n\nIn modern Python it's unlikely to be significantly better than the built-in `json`. The module used by `JSONMixin` is overridable, so users can plug it in again if they want.\r\n\r\nSee pallets/itsdangerous#146 and pallets/werkzeug#1766.", "patch": "", "file_loc": {"base_commit": "024f0d384cf5bb65c76ac59f8ddce464b2dc2ca1", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [8]}}}, {"path": "docs/api.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [287, 288, 289, 290, 291, 293, 295, 296, 297, 298, 300, 302, 304, 305, 306, 308, 309, 310, 311, 313, 314, 315, 316, 317, 322, 325, 327, 328, 329, 331, 332]}}}, {"path": "docs/installation.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [42, 43, 44, 51]}}}, {"path": "src/flask/json/__init__.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [2, 3], "mod": [1, 7, 8, 20, 21, 22, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 38, 39, 40, 41, 44, 45, 46, 47, 48, 49]}, "(None, 'dumps', 179)": {"add": [196], "mod": [180, 181, 182, 183, 185, 186, 187, 190, 191, 192, 193, 195, 203, 204]}, "(None, 'loads', 217)": {"add": [234], "mod": [218, 219, 220, 221, 223, 224, 225, 228, 229, 230, 231, 233, 239, 240, 241, 242, 243]}, "(None, 'jsonify', 296)": {"add": [331], "mod": [297, 298, 299, 300, 301, 302, 304, 305, 307, 308, 309, 310, 311, 312, 314, 318, 320, 321, 322, 324, 335, 336, 338, 339, 340, 341]}, "('JSONEncoder', None, 52)": {"mod": [53, 54, 55, 57, 58, 60, 61]}, "('JSONEncoder', 'default', 64)": {"mod": [65, 66, 67, 69, 70, 72, 73, 74, 75, 76, 77, 78, 79, 91]}, "('JSONDecoder', None, 94)": {"mod": [95, 96, 97, 98]}, "(None, '_dump_arg_defaults', 102)": {"mod": [109, 110, 111, 113, 114]}, "(None, '_load_arg_defaults', 122)": {"mod": [129, 130, 131]}, "(None, 'detect_encoding', 136)": {"mod": [136, 137, 139, 140, 141, 143, 144, 145, 146, 148, 149, 151, 152, 154, 155, 157, 158, 160, 161, 162, 164, 165, 167, 168, 170, 171, 173, 174, 176]}, "(None, 'dump', 208)": {"mod": [209, 212, 213]}, "(None, 'load', 247)": {"mod": [248, 250]}, "(None, 'htmlsafe_dumps', 254)": {"mod": [254, 255, 256, 257, 258, 259, 261, 263, 264, 265, 266, 268, 269, 270, 273, 274, 275, 276, 277, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288]}, "(None, 'htmlsafe_dump', 291)": {"mod": [292, 293]}}}, {"path": "src/flask/json/tag.py", "status": "modified", "Loc": {"(None, None, None)": {"mod": [48]}, "('TagMarkup', None, 169)": {"mod": [170, 172]}, "('TaggedJSONSerializer', None, 215)": {"mod": [225]}}}, {"path": "tests/test_helpers.py", "status": "modified", "Loc": {"(None, None, None)": {"mod": [16]}, "('TestJSON', None, 66)": {"mod": [67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85]}, "('TestJSON', 'test_template_escaping', 252)": {"mod": [256]}}}, {"path": "tox.ini", "status": "modified", "Loc": {"(None, None, None)": {"mod": [4, 27]}}}]}}
{"instance_id": "pallets__flask-3628", "repo": "pallets/flask", "base_commit": "6f2fdc5ac4ad869a21c4c0281d7fa1eb8aa5a689", "problem_statement": "Returning Response and headers causes duplicate headers\n\n<!-- **This issue tracker is a tool to address bugs in Flask itself.\r\nPlease use the Pallets Discord or Stack Overflow for general questions\r\nabout using Flask or issues not related to Flask.** -->\r\n\r\n<!-- If you'd like to report a bug in Flask, fill out the template below. Provide\r\nany extra information that may be useful / related to your problem.\r\nIdeally, create an [MCVE](https://stackoverflow.com/help/mcve), which helps us\r\nunderstand the problem and helps check that it is not caused by something in\r\nyour code. -->\r\n\r\n### Expected Behavior\r\n\r\n```\r\nfrom flask import Flask\r\napp = Flask(__name__)\r\n@app.route('/')\r\ndef issue():\r\n    return {'test': 'test'}, {'Content-Type': 'test'}\r\n```\r\nUsing `curl -v http://127.0.0.1:5000/` to query the view I expect only one `Content-Type` header > `Content-Type: test`\r\n\r\n### Actual Behavior\r\n\r\nDuplicate headers are returned\r\n\r\n```\r\n< Content-Type: application/json\r\n< Content-Type: test\r\n```\r\n\r\n### Environment\r\n\r\n* Python version: 3.8.2\r\n* Flask version: 1.1.2\r\n* Werkzeug version: 1.0.1\r\n\r\n### Context\r\n\r\nThis issue also effects responses created with make_response when using a dict or jsonify body + the headers argument with a 'Content-Type':\r\n\r\n```\r\nfrom flask import Flask, make_response\r\napp = Flask(__name__)\r\n@app.route('/')\r\ndef issue():\r\n    return make_response({'test': 'test'}, {'Content-Type': 'test'})\r\n```\r\n\r\nThis issue is caused by jsonify adding a 'Content-Type' header then make_response uses `extent` to add the additional headers, thus leading to the duplicate.\r\n\r\nReturning a str/bytes body does not have this problem as no 'Content-Type' is added by flask, if one is missing it is added by werkzeug.\r\n\r\nThe reason I came across this issue is we have older code which does `return json.dumps(data), 200, {'Content-Type': 'application/json+somecustomtype'}` and I assumed based on the flask docs that just returning the data and letting flask do the jsonify would be better.", "patch": "", "file_loc": {"base_commit": "6f2fdc5ac4ad869a21c4c0281d7fa1eb8aa5a689", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [30, 31, 32]}}}, {"path": "src/flask/app.py", "status": "modified", "Loc": {"('Flask', 'make_response', 1935)": {"mod": [2048]}}}, {"path": "tests/test_basic.py", "status": "modified", "Loc": {"(None, 'from_response_headers', 1118)": {"mod": [1120, 1121]}, "(None, 'test_response_types', 1092)": {"mod": [1158]}}}]}}
{"instance_id": "pallets__flask-4602", "repo": "pallets/flask", "base_commit": "fb89745408cc02515815c792355c7e883b2d08a4", "problem_statement": "Flask.auto_find_instance_path() can return wrong path for namespace packages installed in development mode\n\nhttps://github.com/pallets/flask/blob/bd56d19b167822a9a23e2e9e2a07ccccc36baa8d/src/flask/scaffold.py#L798\r\n\r\nIf there are several packages under the same namespace, all installed in development mode, like:\r\n\r\n```\r\n~/namespace-package1/\r\n    namespace/\r\n        package1/\r\n            __init__.py\r\n            app.py\r\n    instance/\r\n\r\n~/namespace-package2/\r\n    namespace/\r\n        package2/\r\n            __init__.py\r\n            app.py\r\n    instance/\r\n```\r\nand the code in `namespace.package2` uses `app.instance_path`, then its expected value is `~/namespace-package2/instance` ([\"Uninstalled package\" decision path](https://flask.palletsprojects.com/en/2.1.x/config/#instance-folders)).\r\n\r\nInstead of that the following happens:\r\n* `find_package()` [cuts import info](https://github.com/pallets/flask/blob/bd56d19b167822a9a23e2e9e2a07ccccc36baa8d/src/flask/scaffold.py#L846) to the very top package name, `namespace`,\r\n* then `_find_package_path()` finds module specification for the whole namespace package, which contains several submodule search locations, like `ModuleSpec(name='namespace', loader=<_frozen_importlib_external._NamespaceLoader object at ...>, submodule_search_locations=_NamespacePath(['~/namespace-package1/namespace', '~/namespace-package2/namespace']))`\r\n* and then the quoted line returns first, i.e. _arbitrary_, package from that namespace, e.g. `~/namespace-package1`, which produces wrong instance path.\r\n\r\nSuggestion: pass also `import_name` into `_find_package_path` and use it for resolving ambiguity at this point, like:\r\n\r\n```\r\ndef _find_package_path(root_mod_name, import_name):\r\n...\r\n            if spec.origin in {\"namespace\", None}:\r\n                package_spec = importlib.util.find_spec(import_name)\r\n                package_path = os.path.commonpath(package_spec.submodule_search_locations)\r\n                return os.path.dirname(next(\r\n                    location for location in spec.submodule_search_locations\r\n                    if package_path.startswith(location)\r\n                ))\r\n```", "patch": "", "file_loc": {"base_commit": "fb89745408cc02515815c792355c7e883b2d08a4", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [10]}}}, {"path": "src/flask/scaffold.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [2]}, "(None, '_find_package_path', 783)": {"add": [784], "mod": [783, 786, 788, 794, 799, 800, 802, 803, 806]}, "(None, 'find_package', 835)": {"mod": [848, 849, 853]}}}, {"path": "tests/test_instance_config.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [61], "mod": [1, 18, 19, 20, 21, 22, 24, 26, 27, 30, 45]}}}, {"path": "tox.ini", "status": "modified", "Loc": {"(None, None, None)": {"add": [11]}}}]}}
{"instance_id": "pallets__flask-1971", "repo": "pallets/flask", "base_commit": "01081dbe6cdfa3fc43d8e1fff708d4ed95e1be7e", "problem_statement": "Implement RFC 7233\n\nIt would be great to support [RFC 7233 : Hypertext Transfer Protocol (HTTP/1.1): Range Requests](https://tools.ietf.org/html/rfc7233) for next major version, at least for non multipart/byteranges media type.\n\nI'm willing to implement this, so please share your thoughts about this.\n\nWhat must be done:\n- Modify `send_file` method to support Range Requests\n  - Use existing `conditionnal` parameter to enable Range Requests support ?", "patch": "", "file_loc": {"base_commit": "01081dbe6cdfa3fc43d8e1fff708d4ed95e1be7e", "files": [{"path": "CHANGES", "status": "modified", "Loc": {"(None, None, 20)": {"add": [20]}}}, {"path": "flask/helpers.py", "status": "modified", "Loc": {"(None, 'send_file', 430)": {"add": [448, 502], "mod": [538, 544, 578]}, "(None, None, None)": {"mod": [28, 29]}}}, {"path": "tests/test_helpers.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [18]}, "('TestSendfile', None, 356)": {"add": [464]}}}]}}
{"instance_id": "pallets__flask-2823", "repo": "pallets/flask", "base_commit": "673e5af658cf029e82d87047dcb7ebee3d343d10", "problem_statement": "Flask complains a .env file exists when not using python-dotenv, even though that .env is a directory\n\nI place my virtualenvs in a `.env` directory in my project directory. Flask 1.x sees this directory and thinks it might be a \"dotenv\" file (even though it is a directory).\r\n\r\n### Expected Behavior\r\n\r\n`flask` should ignore a `.env` directory when `python-dotenv` is not installed.\r\n\r\n### Actual Behavior\r\n\r\n`flask` says:\r\n\r\n> * Tip: There are .env files present. Do \"pip install python-dotenv\" to use them.\r\n\r\n### Environment\r\n\r\n* Python version: 3.6.5\r\n* Flask version: 1.0.2\r\n* Werkzeug version: 0.14.1", "patch": "", "file_loc": {"base_commit": "673e5af658cf029e82d87047dcb7ebee3d343d10", "files": [{"path": "flask/cli.py", "status": "modified", "Loc": {"(None, 'load_dotenv', 567)": {"mod": [587]}}}]}}
{"instance_id": "pallets__flask-4220", "repo": "pallets/flask", "base_commit": "8e589daaf2cec6a10262b8ff88801127f2fa14fd", "problem_statement": "`template_filter` decorator typing does not support custom filters with multiple arguments\n\n`template_filter` decorator typing does not support custom filters that take in multiple arguments. Consider:\r\n\r\n```py\r\nfrom flask import Flask\r\n\r\n\r\napp = Flask(__name__)\r\n\r\n\r\n@app.template_filter('foo_bar')\r\ndef foo_bar_filter(foo, bar):\r\n    return f'{foo} {bar}'\r\n```\r\n`mypy` will return the following error message:\r\n```\r\nerror: Argument 1 has incompatible type \"Callable[[Any, Any], Any]\"; expected \"Callable[[Any], str]\"  [arg-type]\r\n```\r\nAs custom filters with multiple arguments are supported by Jinja (https://jinja.palletsprojects.com/en/3.0.x/api/#custom-filters), I think this typing error is a false positive.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.6.13\r\n- Flask version: 2.0.1\r\n- Mypy version: 0.812", "patch": "", "file_loc": {"base_commit": "8e589daaf2cec6a10262b8ff88801127f2fa14fd", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, 10)": {"add": [10]}}}, {"path": "src/flask/typing.py", "status": "modified", "Loc": {"(None, None, None)": {"mod": [43, 44, 45]}}}]}}
{"instance_id": "pallets__flask-3074", "repo": "pallets/flask", "base_commit": "6ed68f015a50ab35b84a8ea71b0f846ca6a75281", "problem_statement": "send_file doesn't urlencode ':/' in unicode attachment_filename\n\n### Expected Behavior\r\n\r\nWhen sending files with unicode filename (with `:` or `/`) they should be downloaded with name from `filename*` field.\r\n\r\n```python\r\n# -*- coding: utf-8 -*-\r\nimport os\r\nfrom flask import Flask, send_from_directory\r\napp = Flask(__name__)\r\n@app.route('/test/', methods=['GET'])\r\ndef test_route():\r\n    tmp_dir = os.getcwd()\r\n    tmp_filename = __file__\r\n    attachment_filename = u'\u0442\u0435\u0441\u0442:\u0442\u0435\u0441\u0442_\u0442\u0435\u0441\u0442.py'\r\n    return send_from_directory(\r\n        tmp_dir,\r\n        tmp_filename,\r\n        as_attachment=True,\r\n        attachment_filename=attachment_filename\r\n    )\r\nif __name__ == '__main__':\r\n    app.run(host='::', port=5000)\r\n```\r\n### Actual Behavior\r\n\r\nSome browsers (Chrome-based/Safari) ignore `filename*` field when it contains colon or slash. For example file `\u0442\u0435\u0441\u0442:\u0442\u0435\u0441\u0442_\u0442\u0435\u0441\u0442.py` gets downloaded in Chrome/Safari as `__.py` but in Firefox as `\u0442\u0435\u0441\u0442_\u0442\u0435\u0441\u0442_\u0442\u0435\u0441\u0442.py` which is acceptable in my opinion.\r\n\r\nFlask response:\r\n`Content-Disposition: attachment; filename*=\"UTF-8''%D1%82%D0%B5%D1%81%D1%82:%D1%82%D0%B5%D1%81%D1%82_%D1%82%D0%B5%D1%81%D1%82.py\"; filename=\":_.py\"`\r\n\r\n### Environment\r\n\r\n* Python version: 2.7.15\r\n* Flask version: 1.0.2\r\n* Werkzeug version: 0.14.1", "patch": "", "file_loc": {"base_commit": "6ed68f015a50ab35b84a8ea71b0f846ca6a75281", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [10]}}}, {"path": "flask/helpers.py", "status": "modified", "Loc": {"(None, 'send_file', 454)": {"mod": [579]}}}, {"path": "tests/test_helpers.py", "status": "modified", "Loc": {"('TestSendfile', None, 436)": {"add": [648]}}}]}}
{"instance_id": "pallets__flask-4099", "repo": "pallets/flask", "base_commit": "50b7dcbab343c93bb6738bbf116a177e72b1d9ec", "problem_statement": "Harmless race condition in tutorial\n\nI was browsing the flaskr tutorial when I noticed an (admittedly quite unlikely) race condition in the `register` view, specifically:\r\n\r\n```py\r\nif not username:\r\n    error = 'Username is required.'\r\nelif not password:\r\n    error = 'Password is required.'\r\nelif db.execute(\r\n    'SELECT id FROM user WHERE username = ?', (username,)\r\n).fetchone() is not None:\r\n    error = f\"User {username} is already registered.\"\r\n\r\nif error is None:\r\n    db.execute(\r\n        'INSERT INTO user (username, password) VALUES (?, ?)',\r\n        (username, generate_password_hash(password))\r\n    )\r\n    db.commit()\r\n    return redirect(url_for('auth.login'))\r\n```\r\n\r\nIf two requests arrive with the right timing, the following can happen:\r\n\r\n```\r\n   Request 1:                                Request 2:\r\nSELECT id\r\n  FROM user\r\n WHERE username = abc\r\n     |\r\n     v\r\nempty, no such user\r\n\r\n                                          SELECT id\r\n                                            FROM user\r\n                                           WHERE username = abc\r\n                                               |\r\n                                               v\r\n                                          empty, no such user\r\n\r\nINSERT INTO user (username, password)\r\n     VALUES (abc, 123)\r\n     |\r\n     v\r\n    ok\r\n\r\n                                          INSERT INTO user (username, password)\r\n                                               VALUES (abc, 456)\r\n                                               |\r\n                                               v\r\n                                          failed UNIQUE constraint -> \r\n                                          -> sqlite3.IntegrityError ->\r\n                                          -> user gets HTTP 500\r\n```\r\n\r\nWhile the likelihood of this happening is pretty small and the harm practically zero (user gets HTTP 500 and has to manually login/choose a different username), I feel like this is not really the sort of good practice the tutorial should teach. I also believe it's important the developer understands that it's the UNIQUE constraint that ensures their app works correctly and not the if condition in the application code (the tutorial mentions SQL injection attacks and explains what protects the developer against them, so I don't really feel this is out of scope).\r\n\r\nIn my own app I've modified the code to the following:\r\n```py\r\nif not username:\r\n    error = 'Username is required.'\r\nelif not password:\r\n    error = 'Password is required.'\r\nelse:\r\n    try:\r\n        db.execute(\r\n            'INSERT INTO users (username, password) VALUES (?, ?)',\r\n            (username, generate_password_hash(password))\r\n        )\r\n        db.commit()\r\n    except IntegrityError:\r\n        error = f\"User {username} is already registered.\"\r\n    else:\r\n        return redirect(url_for('auth.login'))\r\n```\r\n\r\nI suggest something similar be incorporated into the tutorial, with a short explanation (maybe a comment) of how the UNIQUE constraint does the work for the developer and maybe a note about the principle that one should \"ask forgiveness, not permission.\" I'm not sure on how it's better worded, so I'm making this an issue instead of a pull request.\r\n\r\nCheers, and thank you for your great work!", "patch": "", "file_loc": {"base_commit": "50b7dcbab343c93bb6738bbf116a177e72b1d9ec", "files": [{"path": "docs/tutorial/views.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [202], "mod": [94, 95, 96, 97, 100, 101, 102, 103, 104, 105, 128, 129, 130, 131, 132, 133, 134, 136, 137, 138, 139, 141, 142, 143, 144, 145, 146, 147]}}}, {"path": "examples/tutorial/flaskr/auth.py", "status": "modified", "Loc": {"(None, 'register', 47)": {"mod": [63, 64, 65, 66, 67, 70, 71, 72, 73, 74, 75, 76, 77]}}}]}}
{"instance_id": "pallets__flask-1443", "repo": "pallets/flask", "base_commit": "f17e6061fcffdc290f615d3fdc9d949e9e719574", "problem_statement": "json_encoder not invoked from flask.jsonify\n\nI created a custom JSON encoder class extended from flask.json.JSONEncoder but it is not called when calling flask.jsonify. Additionally, I removed my custom JSON encoder and confirmed that  flask.json.JSONEncoder isn't called either via a break statement in Pycharm.\n\n```\nfrom flask import Flask\nfrom flask import jsonify\nfrom flask.json import JSONEncoder\n\nclass MyEncoder(JSONEncoder):\n    def default(self, obj):\n        if hasattr(obj, '__json__'):\n            return obj.__json__()\n        else:\n            try:\n                iterable = iter(obj)\n            except TypeError:\n                pass\n            else:\n                return list(iterable)\n\n        return JSONEncoder.default(self, obj)\n\n\nclass MyClass(object):\n    key = 'a'\n    value = 'b'\n\n    def __json__(self):\n        return {'key': self.key, 'value': self.value}\n\napp = Flask(__name__)\napp.json_encoder = MyEncoder\n\n@app.route('/')\ndef hello_world():\n    return jsonify(MyClass())\n\n\nif __name__ == '__main__':\n    app.run(debug=True)\n```", "patch": "", "file_loc": {"base_commit": "f17e6061fcffdc290f615d3fdc9d949e9e719574", "files": [{"path": "AUTHORS", "status": "modified", "Loc": {"(None, None, None)": {"add": [17, 20], "mod": [35]}}}, {"path": "CHANGES", "status": "modified", "Loc": {"(None, None, None)": {"add": [10]}}}, {"path": "docs/security.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [98, 100, 101, 102, 103, 105, 106, 107, 108, 109, 111, 112, 113, 114, 115, 116, 117, 119, 120, 121, 122, 123, 125, 127, 128, 129, 130, 132, 133, 134, 135, 137, 138, 140, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 161, 162, 163, 164, 165, 166, 167, 168, 170, 171, 172, 173, 174, 175]}}}, {"path": "flask/json.py", "status": "modified", "Loc": {"(None, 'jsonify', 201)": {"add": [244], "mod": [202, 203, 204, 205, 225, 226, 248, 249]}}}, {"path": "tests/test_helpers.py", "status": "modified", "Loc": {"('TestJSON', 'test_json_as_unicode', 121)": {"add": [122], "mod": [124, 125, 126, 127, 129, 130, 131, 132]}, "('TestJSON', None, 32)": {"mod": [34, 35, 37, 38, 39, 40, 42, 43, 45, 46, 47, 48, 49, 50, 106, 107, 121]}}}]}}
{"instance_id": "pallets__flask-2731", "repo": "pallets/flask", "base_commit": "f808c20139649b747f604492bc33b61a7dd3e13a", "problem_statement": "Flask 1.0 backwards-incompat with double-slash/no-slash re. #2629\n\nThis is a major backwards-compat breaking change, but I suspect not the intended design and hopefully easy to fix.\r\n\r\nThe issue is related to PR #2629, and this example follows from that:\r\n\r\nGiven blueprint `bp` and app `app`:\r\n\r\n```python\r\n@bp.route('b/')\r\ndef tmp():\r\n    return \"URI should be '/a/b/\"\r\n\r\napp.register_blueprint(bp, url_prefix='/a/')\r\n```\r\n\r\nIn Flask 0.12 the URL is correctly `/a/b`, but in Flask 1.0 it's `/ab`.\r\n\r\nSince issue #2629 relates to resolve double-slashes, I imagine this is a bug (and not a design decision) - and the correct solution would be to remove a slash only when there are two.", "patch": "", "file_loc": {"base_commit": "f808c20139649b747f604492bc33b61a7dd3e13a", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [145, 188]}}}, {"path": "flask/blueprints.py", "status": "modified", "Loc": {"('BlueprintSetupState', '__init__', 25)": {"add": [55]}}}, {"path": "tests/test_blueprints.py", "status": "modified", "Loc": {"(None, 'test_blueprint_url_definitions', 117)": {"mod": [117]}}}]}}
{"instance_id": "pallets__flask-2594", "repo": "pallets/flask", "base_commit": "22708b048d224a5590fa28d86ca02bac52294f90", "problem_statement": "add ssl_context option to `flask run`\n\n### Expected Behaviour\r\n\r\nI expect to be able to pass the `flask run` command any of the options which are valid for the `Flask.run()` method:\r\n\r\n```sh\r\n$ FLASK_APP=myapp/run.py FLASK_DEBUG=1 flask run --host=0.0.0.0 --ssl_context=adhoc\r\n* Running on https://0.0.0.0:5000/ (Press CTRL+C to quit)\r\n```\r\n\r\nSpecifically, I want to pass `ssl_context=adhoc`, but it seems sensible to extend the command to accept all valid keyword arguments for `Flask.run()` / `werkzeug.serving.run_simple()`.\r\n\r\n### Actual Behaviour\r\n```\r\nError: no such option: --ssl_context\r\nflask run --host=0.0.0.0 --ssl_context=adhoc exited with code 2\r\n```\r\n\r\n### Environment\r\n\r\n* Python version: 3.5.2\r\n* Flask version: 0.12.2\r\n* Werkzeug version: 0.12.2", "patch": "", "file_loc": {"base_commit": "22708b048d224a5590fa28d86ca02bac52294f90", "files": [{"path": "CHANGES", "status": "modified", "Loc": {"(None, None, None)": {"add": [120, 156]}}}, {"path": "flask/cli.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [16, 23, 601, 606], "mod": [26, 608, 611, 614]}, "(None, 'run_command', 619)": {"mod": [620, 645]}}}, {"path": "tests/test_cli.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [16, 17], "mod": [27, 28]}, "(None, 'test_dotenv_optional', 462)": {"add": [466]}}}]}}
{"instance_id": "pallets__flask-266", "repo": "pallets/flask", "base_commit": "e4c712ffd2682f963906e1d0d27e67b7f83d95ce", "problem_statement": "Blueprint template lookup not documented enough\n\nThe new blueprint template lookup scheme where the templates folder is just added to the searchpath instead of doing some weird stuff with the names as before. The documentation has to be clearer about that.", "patch": "", "file_loc": {"base_commit": "e4c712ffd2682f963906e1d0d27e67b7f83d95ce", "files": [{"path": "docs/blueprints.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [179, 180, 181, 182, 183, 188]}}}]}}
{"instance_id": "pallets__flask-2118", "repo": "pallets/flask", "base_commit": "8cd0b03beeac4a41c398ea365475c651c484a9ee", "problem_statement": "config.from_pyfile crashes on Python 3 when source isn't encoded in default encoding\n\nwhen I read my instance config file, I get an error. \r\n\r\n> exec(compile(config_file.read(), filename, 'exec'), d.__dict__)\r\n> UnicodeDecodeError: 'gbk' codec can't decode byte 0x80 in position 437: illegal multibyte sequence\r\nThen I modify the code of config.from_pyfile to this\r\n\r\n> with open(filename, 'rb') as config_file:\r\nThe problem is resolved.", "patch": "", "file_loc": {"base_commit": "8cd0b03beeac4a41c398ea365475c651c484a9ee", "files": [{"path": "CHANGES", "status": "modified", "Loc": {"(None, None, None)": {"add": [10]}}}, {"path": "flask/config.py", "status": "modified", "Loc": {"('Config', 'from_pyfile', 111)": {"mod": [129]}}}, {"path": "tests/test_config.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [13, 14], "mod": [10, 12]}, "(None, 'test_get_namespace', 168)": {"add": [189]}}}]}}
{"instance_id": "pallets__flask-2023", "repo": "pallets/flask", "base_commit": "85fa8aabf5a7bd0adf204f0c2dacbba1fa6683de", "problem_statement": "How should logging in Flask look like?\n\nFlask started to ship with a default, hardcoded logging handler. Unfortunately this setup makes it harder to install custom logging setups, because then you'll have to undo all the things Flask did to the app logger, or replace the `app.logger` entirely. A symptom of this is #1993, where Flask's own logger had to be tweaked yet again such that messages didn't get logged twice (once via Flask's setup, once via the custom one).\n\nMy question is: **Do we even want Flask to do any logging setup?** It appears that this sort of default logging is only useful during development, so maybe it makes sense to set up a default logging handler in the new Flask CLI instead of from within the application.", "patch": "", "file_loc": {"base_commit": "85fa8aabf5a7bd0adf204f0c2dacbba1fa6683de", "files": [{"path": "CHANGES", "status": "modified", "Loc": {"(None, None, None)": {"add": [108]}}}, {"path": "docs/config.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [331], "mod": [202, 204, 205, 207, 209, 211, 212, 213, 215]}}}, {"path": "docs/contents.rst.inc", "status": "modified", "Loc": {"(None, None, None)": {"add": [18]}}}, {"path": "docs/errorhandling.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [146, 147, 149, 150, 151, 152, 153, 155, 156, 157, 158, 159, 161, 162, 163, 165, 166, 167, 168, 169, 170, 171, 172, 173, 175, 176, 177, 178, 179, 180, 181, 183, 184, 185, 187, 188, 189, 192, 193, 195, 196, 197, 198, 199, 200, 202, 203, 204, 206, 207, 208, 209, 210, 211, 212, 213, 214, 216, 217, 218, 220, 221, 222, 223, 224, 225, 227, 229, 230, 232, 233, 234, 235, 236, 238, 239, 240, 242, 244, 245, 247, 249, 250, 251, 252, 253, 254, 255, 257, 259, 260, 262, 263, 265, 267, 268, 269, 270, 271, 274, 275, 277, 278, 279, 281, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 310, 311, 312, 314, 315, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 329, 332, 333, 335, 336, 337, 338, 339, 340, 341, 343, 344, 345, 347, 348, 349, 350, 351, 352]}}}, {"path": "flask/app.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [32], "mod": [19, 20, 21, 22, 40, 41]}, "('Flask', None, 70)": {"mod": [267, 268, 269, 270, 271, 297, 298, 616]}, "('Flask', '__init__', 352)": {"mod": [395, 396, 397]}, "('Flask', 'logger', 617)": {"mod": [618, 619, 620, 621, 623, 624, 625, 629, 630, 631, 632, 633, 634, 635, 636]}}}, {"path": "flask/logging.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [13, 41, 49], "mod": [1, 2, 3, 4, 6, 8, 9, 10, 17, 18, 19, 22, 23, 24, 25, 26, 27, 28]}, "(None, '_proxy_stream', 32)": {"mod": [32, 33, 34, 35, 37, 38, 39, 40]}, "(None, '_should_log_for', 43)": {"mod": [43, 44, 45, 46]}, "(None, 'create_logger', 50)": {"mod": [51, 52, 53, 54, 55, 57, 59, 60, 61, 62, 63, 65, 66, 67, 68, 70, 71, 72, 73, 75, 76, 77, 79, 80, 81, 83, 84, 85, 86, 87, 88, 89, 91, 92]}}}, {"path": "tests/test_basic.py", "status": "modified", "Loc": {"(None, None, None)": {"add": [1023]}, "(None, 'test_teardown_request_handler_error', 739)": {"mod": [741]}, "(None, 'test_error_handling', 816)": {"mod": [817]}, "(None, 'test_error_handling_processing', 862)": {"mod": [863]}, "(None, 'test_baseexception_error_handling', 884)": {"mod": [885]}, "(None, 'apprunner', 1427)": {"mod": [1428]}}}, {"path": "tests/test_helpers.py", "status": "modified", "Loc": {"(None, None, None)": {"mod": [12, 16, 18, 19, 22, 23, 25]}, "('TestLogging', None, 663)": {"mod": [663, 664, 665, 666, 667, 668, 669, 670, 672, 673, 675, 676, 677, 678, 679, 681, 682, 683, 685, 686, 687, 688, 689, 690, 691, 693, 694, 696, 697, 698, 699, 700, 702, 703, 704, 705, 706, 707, 709, 710, 711, 713, 714, 715, 717, 718, 719, 720, 721, 723, 724, 725, 727, 728, 729, 730, 732, 733, 734, 735, 736, 738, 739, 740, 742, 743, 744, 746, 747, 748, 749]}}}, {"path": "tests/test_subclassing.py", "status": "modified", "Loc": {"(None, None, None)": {"mod": [13]}, "(None, 'test_suppressed_exception_logging', 18)": {"mod": [25, 26, 32, 36, 37]}, "(None, 'index', 29)": {"mod": [30]}}}, {"path": "tests/test_templating.py", "status": "modified", "Loc": {"(None, 'test_template_loader_debugging', 402)": {"mod": [402, 422, 423, 424, 425, 426, 428, 429, 431, 432, 433, 434]}}}, {"path": "tests/test_testing.py", "status": "modified", "Loc": {"(None, 'test_test_client_context_binding', 209)": {"mod": [210]}}}]}}
{"instance_id": "pallets__flask-2866", "repo": "pallets/flask", "base_commit": "465da9f610a04d379bb39a0ff03fb6c0b0ea1c45", "problem_statement": "DispatcherMiddleware with different loggers per app in flask 1.0\n\nAfter upgrading to flask 1.0 logging from different apps using DispatcherMiddleware, each log emitted is written to all handlers in the different apps. I assume this caused by `app.logger` always having the name `flask.app`, maybe?\r\n\r\nHere is a example:\r\n\r\n\r\n```\r\nfrom werkzeug.wsgi import DispatcherMiddleware\r\nfrom flask import Flask\r\nfrom logging.handlers import RotatingFileHandler\r\n\r\n\r\nhandler1 = RotatingFileHandler('app1.log')\r\napp1 = Flask('app1')\r\napp1.logger.addHandler(handler1)\r\n\r\nhandler2 = RotatingFileHandler('app2.log')\r\napp2 = Flask('app2')\r\napp2.logger.addHandler(handler2)\r\n\r\n\r\n@app1.route(\"/\")\r\ndef hello():\r\n    app1.logger.error(\"from app1\")\r\n    return ''\r\n\r\n\r\n@app2.route(\"/\")\r\ndef hello2():\r\n    app2.logger.error(\"from app2\")\r\n    return ''\r\n\r\n\r\napp = DispatcherMiddleware(app1, {\r\n    '/app2': app2\r\n})\r\n```\r\n\r\nRun with\r\n```\r\nuwsgi --socket 0.0.0.0:8000 --protocol=http -w app --callable app\r\n```\r\n\r\nAnd then make a request to / and /app2/. Each error log will be written in both logfiles.\r\n\r\n### Environment\r\n\r\n* Python version: 3.6.5\r\n* Flask version: 1.0.2\r\n* Werkzeug version: 0.14.1\r\n\r\nMy actual app is using `current_app.logger` with blueprints with the same behaviour, but I assume it the same issue.", "patch": "", "file_loc": {"base_commit": "465da9f610a04d379bb39a0ff03fb6c0b0ea1c45", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [20]}}}, {"path": "docs/config.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [385]}}}, {"path": "docs/errorhandling.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [234]}}}, {"path": "docs/logging.rst", "status": "modified", "Loc": {"(None, None, None)": {"mod": [1, 6, 7, 8, 9]}}}, {"path": "src/flask/app.py", "status": "modified", "Loc": {"('Flask', 'logger', 655)": {"mod": [656, 657, 659, 660, 662, 663, 665, 667, 668, 669, 670, 671]}}}, {"path": "src/flask/logging.py", "status": "modified", "Loc": {"(None, 'create_logger', 59)": {"mod": [60, 69]}}}, {"path": "tests/test_logging.py", "status": "modified", "Loc": {"(None, 'reset_logging', 21)": {"mod": [26]}, "(None, 'test_logger', 44)": {"mod": [45]}}}, {"path": "tests/test_templating.py", "status": "modified", "Loc": {"(None, 'test_template_loader_debugging', 409)": {"mod": [433]}}}]}}
{"instance_id": "pallets__flask-5160", "repo": "pallets/flask", "base_commit": "c8cf4694c60f0d81809468a1b45ec730496cc546", "problem_statement": "Switch to importlib breaks scripts with `app.run()`\n\nWith a trivial script [using `app.run()`](https://flask.palletsprojects.com/en/2.3.x/server/#in-code) such as:\r\n\r\n```python3\r\nfrom flask import Flask\r\n\r\napp = Flask(__name__)\r\n\r\nif __name__ == \"__main__\":\r\n    app.run(debug=True)\r\n```\r\n\r\nThe current git `main` breaks with:\r\n\r\n```pytb\r\nTraceback (most recent call last):\r\n  File \"/home/florian/tmp/flask/app.py\", line 3, in <module>\r\n    app = Flask(__name__)\r\n          ^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/app.py\", line 376, in __init__\r\n    instance_path = self.auto_find_instance_path()\r\n                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/app.py\", line 630, in auto_find_instance_path\r\n    prefix, package_path = find_package(self.import_name)\r\n                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/scaffold.py\", line 898, in find_package\r\n    package_path = _find_package_path(import_name)\r\n                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"/home/florian/tmp/flask/src/flask/scaffold.py\", line 858, in _find_package_path\r\n    spec = importlib.util.find_spec(root_mod_name)\r\n           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\r\n  File \"<frozen importlib.util>\", line 114, in find_spec\r\nValueError: __main__.__spec__ is None\r\n```\r\n\r\nThis seems to be a regression due to 84e11a1e827c0f55f9b9ee15952eddcf8a6492e0 from #5157.\r\n\r\nEnvironment:\r\n\r\n- Python version: 3.11.4\r\n- Flask version: git main", "patch": "", "file_loc": {"base_commit": "c8cf4694c60f0d81809468a1b45ec730496cc546", "files": [{"path": "CHANGES.rst", "status": "modified", "Loc": {"(None, None, None)": {"add": [7]}}}, {"path": "src/flask/helpers.py", "status": "modified", "Loc": {"(None, 'get_root_path', 562)": {"mod": [578, 579, 584]}}}, {"path": "src/flask/scaffold.py", "status": "modified", "Loc": {"(None, '_matching_loader_thinks_module_is_package', 782)": {"mod": [782, 783, 785, 786, 787, 788, 789, 790, 792, 794, 795, 796, 797, 799, 800, 801, 802, 803, 804]}, "(None, '_find_package_path', 816)": {"mod": [825, 826, 827, 828, 829, 831, 832, 833, 834, 835, 836, 837, 838, 839, 840, 841, 842, 843, 844, 845, 846, 847, 848, 849, 850, 851, 852, 853, 854, 855, 857, 858, 859, 861, 862, 865, 866, 867, 868, 869, 870, 871, 872, 873, 875, 877, 878, 879, 880, 882]}}}]}}
{"instance_id": "pallets__flask-1224", "repo": "pallets/flask", "base_commit": "f88765d504ce2fa9bc3926c76910b11510522892", "problem_statement": "Starting up a public server.\n\nI ran into this problem today with one of my applications trying to make it public to my local network.  \n\nC:\\Users\\Savion\\Documents\\GitHub\\Example-Flask-Website>flask\\Scripts\\python run.\npy\n- Running on http://127.0.0.1:5000/\n- Restarting with reloader\n  10.101.37.124 - - [26/Oct/2014 15:51:23] \"GET / HTTP/1.1\" 404 -\n- Running on http://0.0.0.0:5000/\n  10.101.37.124 - - [26/Oct/2014 15:51:38] \"GET / HTTP/1.1\" 404 -\n\nThe problem that i run into is the fact that this app continuously attempts to default to localhost. It is not until 2 Ctrl + C, that it goes to 0.0.0.0, then I still receive a 404 error in my browser.  I do have routes that are valid when running locally. I have tried to create a new virtualenv and i still recieve the same error, I reset the firewall rule on this application.  All effort that did not return rewarded.\n\nAny Ideas onto why my app makes an attempt to startup on the localhost first then moves over, but then returns a 404?", "patch": "", "file_loc": {"base_commit": "f88765d504ce2fa9bc3926c76910b11510522892", "files": [{"path": "flask/views.py", "Loc": {}}]}}
{"instance_id": "pallets__flask-834", "repo": "pallets/flask", "base_commit": "2d8a21c7321a9ead8e27208b49a18f4b8b27e2c1", "problem_statement": "How to get the serialized version of the session cookie in 0.10?\n\nIn version 0.9 I could simply get the value of the `session` like this: \n\n```\nflask.session.serialize()\n```\n\nBut after upgrading to 0.10 this is not working anymore.. what's the alternative? How can I get the session value?\n\n(`flask.request.cookies.get('session')` is not good for me, because I would like to get the session right after login, so it's not part of the request yet)", "patch": "", "file_loc": {"base_commit": "2d8a21c7321a9ead8e27208b49a18f4b8b27e2c1", "files": [{"path": "flask/sessions.py", "Loc": {"('SecureCookieSessionInterface', 'get_signing_serializer', 308)": {"mod": []}, "('TaggedJSONSerializer', 'dumps', 60)": {"mod": []}}, "status": "modified"}]}}
{"instance_id": "pallets__flask-4015", "repo": "pallets/flask", "base_commit": "22d82e70b3647ed16c7d959a939daf533377382b", "problem_statement": "2.0.0: build requires ContextVar module\n\nSimple I cannot find it.\r\n```console\r\n+ /usr/bin/python3 setup.py build '--executable=/usr/bin/python3 -s'\r\nTraceback (most recent call last):\r\n  File \"setup.py\", line 4, in <module>\r\n    setup(\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/__init__.py\", line 144, in setup\r\n    return distutils.core.setup(**attrs)\r\n  File \"/usr/lib64/python3.8/distutils/core.py\", line 121, in setup\r\n    dist.parse_config_files()\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/dist.py\", line 689, in parse_config_files\r\n    parse_configuration(self, self.command_options,\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 121, in parse_configuration\r\n    meta.parse()\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 426, in parse\r\n    section_parser_method(section_options)\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 399, in parse_section\r\n    self[name] = value\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 184, in __setitem__\r\n    value = parser(value)\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 515, in _parse_version\r\n    version = self._parse_attr(value, self.package_dir)\r\n  File \"/usr/lib/python3.8/site-packages/setuptools/config.py\", line 349, in _parse_attr\r\n    module = import_module(module_name)\r\n  File \"/usr/lib64/python3.8/importlib/__init__.py\", line 127, in import_module\r\n    return _bootstrap._gcd_import(name[level:], package, level)\r\n  File \"<frozen importlib._bootstrap>\", line 1014, in _gcd_import\r\n  File \"<frozen importlib._bootstrap>\", line 991, in _find_and_load\r\n  File \"<frozen importlib._bootstrap>\", line 975, in _find_and_load_unlocked\r\n  File \"<frozen importlib._bootstrap>\", line 671, in _load_unlocked\r\n  File \"<frozen importlib._bootstrap_external>\", line 783, in exec_module\r\n  File \"<frozen importlib._bootstrap>\", line 219, in _call_with_frames_removed\r\n  File \"/home/tkloczko/rpmbuild/BUILD/Flask-2.0.0/src/flask/__init__.py\", line 7, in <module>\r\n    from .app import Flask\r\n  File \"/home/tkloczko/rpmbuild/BUILD/Flask-2.0.0/src/flask/app.py\", line 19, in <module>\r\n    from werkzeug.local import ContextVar\r\nImportError: cannot import name 'ContextVar' from 'werkzeug.local' (/usr/lib/python3.8/site-packages/werkzeug/local.py)\r\n```", "patch": "", "file_loc": {"base_commit": "22d82e70b3647ed16c7d959a939daf533377382b", "files": [{"path": "setup.py", "Loc": {"(None, None, None)": {"mod": [7]}}, "status": "modified"}]}}
{"instance_id": "pallets__flask-2977", "repo": "pallets/flask", "base_commit": "43e2d7518d2e89dc7ed0b4ac49b2d20211ad1bfa", "problem_statement": "Serial port access problem in DEBUG mode.\n\n### Expected Behavior\r\n\r\nSending commands through the serial port.\r\n\r\n```python\r\napp = Flask(__name__)\r\nserialPort = serial.Serial(port = \"COM5\", baudrate=1000000,\r\n                           bytesize=8, timeout=2, stopbits=serial.STOPBITS_ONE)\r\n\r\nlamp = {\r\n   1 : {'name' : 'n1', 'state' : True},\r\n   2 : {'name' : 'n2', 'state' : True} \r\n}\r\n\r\n@app.route(\"/\")\r\ndef hello():\r\n   templateData = {\r\n      'lamp': lamp\r\n      }\r\n\r\n   \r\n   return render_template('main.html', **templateData)\r\n\r\n\r\n@app.route(\"/setPin/<action>\")\r\ndef action(action):\r\n\r\n   if action == \"on\":\r\n\r\n      serialPort.write(b\"n2c1111\\r\\n\")\r\n      lamp[1][\"state\"] = True\r\n\r\n   if action == \"off\":\r\n      serialPort.write(b\"n2c0000\\r\\n\")\r\n      lamp[1][\"state\"] = False\r\n\r\n\r\n   templateData = {\r\n      'lamp': lamp\r\n   }\r\n\r\n   return render_template('main.html', **templateData)\r\n\r\nif __name__ == \"__main__\":\r\n   app.run(host='0.0.0.0', port=5000, debug=True)\r\n```\r\n\r\n\r\n### Actual Behavior\r\n\r\nI can not access the serial port with  FLASK_ENV = development and FLASK_DEBUG = 1. Everything works fine with DEBUG mode disabled.\r\n\r\n```pytb\r\nFLASK_APP = app.py\r\nFLASK_ENV = development\r\nFLASK_DEBUG = 1\r\nIn folder C:/Users/user/PycharmProjects/Ho_server\r\nC:\\Users\\user\\Anaconda3\\python.exe -m flask run\r\n * Serving Flask app \"app.py\" (lazy loading)\r\n * Environment: development\r\n * Debug mode: on\r\n * Restarting with stat\r\n * Debugger is active!\r\n * Debugger PIN: 138-068-963\r\n * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)\r\n127.0.0.1 - - [30/Oct/2018 10:49:27] \"GET /setPin/on HTTP/1.1\" 500 -\r\nTraceback (most recent call last):\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\flask\\_compat.py\", line 35, in reraise\r\n    raise value\r\n  File \"C:\\Users\\user\\PycharmProjects\\H_server\\app.py\", line 8, in <module>\r\n    bytesize=8, timeout=2, stopbits=serial.STOPBITS_ONE)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\serial\\serialwin32.py\", line 31, in __init__\r\n    super(Serial, self).__init__(*args, **kwargs)\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\serial\\serialutil.py\", line 240, in __init__\r\n    self.open()\r\n  File \"C:\\Users\\user\\Anaconda3\\lib\\site-packages\\serial\\serialwin32.py\", line 62, in open\r\n    raise SerialException(\"could not open port {!r}: {!r}\".format(self.portstr, ctypes.WinError()))\r\nserial.serialutil.SerialException: could not open port 'COM5': PermissionError(13, 'Access is denied.', None, 5)\r\n```\r\n\r\n### Environment\r\n\r\n* Python version: 3.6.5\r\n* Flask version: 1.0.2", "patch": "", "file_loc": {}}
{"instance_id": "pallets__flask-1749", "repo": "pallets/flask", "base_commit": "1a7fd980f8579bd7d7d53c812a77c1dc64be52ba", "problem_statement": "JSONEncoder and aware datetimes\n\nI was surprised to see that though flask.json.JSONEncoder accepts datetime objects, it ignores the timezone. I checked werkzeug.http.http_date and it can handle timezone aware dates just fine if they are passed in, but the JSONEncoder insists on transforming the datetime to a timetuple, like this\n\n `return http_date(o.timetuple())`\n\nThis means i have to convert all my dates to utc before encoding them, otherwise I should overwrite the dafault() method in the encoder. Can you help me understand why the encoder was made to function with naive dates only?\nThx", "patch": "", "file_loc": {"base_commit": "1a7fd980f8579bd7d7d53c812a77c1dc64be52ba", "files": [{"path": "flask/json.py", "Loc": {"('JSONEncoder', 'default', 60)": {"mod": [78]}}, "status": "modified"}]}}
